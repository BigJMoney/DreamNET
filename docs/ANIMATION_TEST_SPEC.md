# DreamNET ‚Äî Animation System Test Content Specification

This document defines **test content**, not test harness mechanics, for validating
the DreamNET animation system (`playFrames()` and `play()`).

The goal is to systematically exercise:
- framebuffer boundaries
- character class handling
- ANSI SGR parsing and state
- animation sequencing and determinism
- clipping, cropping, and overwrite behavior

This spec intentionally avoids implementation details and focuses on *what must
be tested*, not *how tests are executed*.

---

## A. Test Matrix Axes

Animation correctness failures overwhelmingly occur at **boundaries** and under
**stateful rendering conditions**. All test content is generated by combining the
axes below.

---

## 1. Boundary Targets (Framebuffer Space)

Let:

- `C = cols`
- `R = rows`

### X-axis Anchors
- `X0 = 0`
- `X1 = 1`
- `XL = C - 1`
- `XLm1 = C - 2`
- `XO = C` (first out-of-bounds column)

### Y-axis Anchors
- `Y0 = 0`
- `Y1 = 1`
- `YB = R - 1`
- `YBm1 = R - 2`
- `YO = R` (first out-of-bounds row)

### Required Corner Targets
- `(X0, Y0)`
- `(XL, Y0)`
- `(X0, YB)`
- `(XL, YB)`

### Required Row-Wrap Targets
- Start of row: `(X0, y)`
- End of row: `(XL, y)`
- Cross-row boundary: `(XLm1, y)` with multi-character writes

### Required Rectangle Edge Crossings
- `x + w == C`
- `x + w == C + 1`
- `y + h == R`
- `y + h == R + 1`
- `x == C - 1, w == 2`
- `y == R - 1, h == 2`

These cases lock down clipping and cropping behavior.

---

## 2. Placement Patterns (String ‚Üí Rect ‚Üí Framebuffer)

Each boundary target is tested with one or more **placement patterns**.

### P0 ‚Äî Single Glyph
- `"X"` written at `(x, y)`
- `w = 1, h = 1`

### P1 ‚Äî Two Glyph
- `"AB"` written at `(x, y)`
- `w = 2, h = 1`

### P2 ‚Äî Cross-Column Wrap
- `"WXYZ"` written at `(C - 2, y)`
- `w = 4, h = 1`
- Forces last-column + out-of-bounds behavior

### P3 ‚Äî Newline Boundary
- `"A\nB"`
- `"\nA"`
- `"A\n"`
- Must be tested near row boundaries and column edges

### P4 ‚Äî Trailing Whitespace
- `"A  "`
- `"A \nB"`
- Spaces land at `(XL, y)` and beyond

### P5 ‚Äî Partial Overwrite (State Carry)
- Frame N writes `"AAAA"` (with attributes)
- Frame N+1 writes `"bb"` overlapping center cells

This pattern is mandatory for detecting attribute bleed.

---

## 3. Character Class Bundles

Tests operate on **representative bundles**, not exhaustive glyph lists.

### G0 ‚Äî ASCII Basic
- `"A"`, `"z"`, `"0"`
- `"!"`, `"?"`, `"@"`
- `"["`, `"]"`, `"\"`, `"_"`

### G1 ‚Äî Whitespace / Control (Policy-Locking)
- `" "` (space)
- `"\t"` (tab)
- `"\r"` (carriage return)
- `"\n"` (newline)
- `"\x00"` (NUL, if possible)

Expected behavior must be explicit (normalize, strip, replace, etc.).

### G2 ‚Äî CP437 Box Drawing
- `"‚îÄ"`, `"‚îÇ"`
- `"‚îå"`, `"‚îê"`, `"‚îî"`, `"‚îò"`
- `"‚îú"`, `"‚î§"`, `"‚î¨"`, `"‚î¥"`, `"‚îº"`

### G3 ‚Äî CP437 Block / Shade
- `"‚ñë"`, `"‚ñí"`, `"‚ñì"`, `"‚ñà"`

### G4 ‚Äî Non-CP437 / Wide / Combining (Safe Degradation)
- `"üôÇ"` (emoji)
- `"e\u0301"` (combining accent)
- `"Êº¢"` (CJK wide)

Renderer behavior must be explicitly enforced:
- replace
- strip
- or normalize

### G5 ‚Äî ANSI SGR Sequences
Tokens where **string length ‚â† visible glyph count**:
- `\x1b[31mX\x1b[0m`
- `\x1b[1;33;47mY\x1b[0m`
- `\x1b[m` (empty params)
- `\x1b[` (incomplete sequence at end)

These must never crash parsing.

---

## B. Core Boundary Matrix

This suite forms the **baseline correctness net** and is defined as a matrix:

> **Matrix 1: Boundary √ó Placement √ó GlyphClass**

The intent is to systematically cover boundary behavior without exploding test volume.

---

### B.1 Boundary Targets Used

The boundary matrix uses a fixed set of target points:

- 4 corners:
  - `(X0, Y0)`
  - `(XL, Y0)`
  - `(X0, YB)`
  - `(XL, YB)`

- 2 midpoints:
  - `(floor(C / 2), 0)`
  - `(0, floor(R / 2))`

- 2 row-wrap targets:
  - `(C - 2, yMid)`
  - `(C - 1, yMid)`

- 2 bottom-edge targets:
  - `(xMid, R - 2)`
  - `(xMid, R - 1)`

Total: **12 targets**

---

### B.2 Placement Patterns to Apply

For each boundary target, placement patterns are selected by rule:

**Always apply (core):**
- **P0** ‚Äî Single Glyph
- **P1** ‚Äî Two Glyph
- **P2** ‚Äî Cross-Column Wrap

**Conditionally apply:**
- For any glyph bundle / test string with `\n` potential: also apply **P3** ‚Äî Newline Boundary
- For whitespace-sensitive bundles: also apply **P4** ‚Äî Trailing Whitespace
- For style/state tests: also apply **P5** ‚Äî Partial Overwrite (State Carry)

This selection logic is part of the test contract.

---

### B.3 Glyph Bundles to Apply

Glyph bundles are selected by rule:

**Always include:**
- **G0** ‚Äî ASCII Basic
- **G2** ‚Äî CP437 Box Drawing
- **G3** ‚Äî CP437 Block / Shade
- **G5** ‚Äî ANSI SGR Sequences

**Include behind an explicit ‚Äúpolicy chosen‚Äù flag (but still run to lock behavior):**
- **G1** ‚Äî Whitespace / Control (Policy-Locking)
- **G4** ‚Äî Non-CP437 / Wide / Combining (Safe Degradation)

The ‚Äúpolicy chosen‚Äù flag exists because these bundles require an explicit normalization /
replacement decision. Once the policy is selected, these cases must run to prevent regressions.

---

### B.4 Required Combination Rules (Volume Control)

To keep the suite comprehensive but bounded:

For each boundary target:
- Run **P0** with *all enabled* glyph bundles (always-set + policy-gated bundles when enabled)
- Run **P2** with:
  - `G0`
  - `G2`
  - `G5`
- Run **P5** with:
  - `G5`
  - one non-SGR bundle (`G2` or `G3`)

This provides:
- broad correctness coverage via P0
- wrap/crop validation via P2
- attribute/state validation via P5


---

## C. Animation-Specific Content

All animation test content must explicitly exercise the following phases:
- first frame (initial mutation)
- middle frames (steady-state mutation)
- hold-only frames (no-op mutation)
- final frame (last mutation before idle)
- idle transition after completion


### Suite A ‚Äî playFrames() Sequencing Proof

Purpose: verify frame ordering, holds, and determinism.

**Content**
1. Clear frame (known baseline)
2. For `i = 0..N-1`:
   - Write token `"i"` or `"[i]"` at:
     - `x = i % C`
     - `y = floor(i / C) % R`
3. Every `k` frames:
   - Insert a `hold`-only frame
4. Final frame:
   - Draw small border + `"DONE"` marker

**Assertions Supported**
- Frames apply in-order
- Hold frames do not mutate framebuffer
- Engine idles after final frame
- Replays produce identical snapshots

Each animation scenario must be executed at least twice without
reinitializing unrelated engine or renderer state.

Identical framebuffer output is required at defined checkpoints.

---

### Suite B ‚Äî play() Real Animation

Purpose: validate higher-level animation composition.

**Phase 1 ‚Äî Baseline**
- Full border
- Title text
- Color legend row (SGR)

**Phase 2 ‚Äî Moving Object**
- 3√ó2 box
- Moves diagonally
- Bounces off framebuffer edges
- One visible step per frame or beat

**Phase 3 ‚Äî Partial Overwrite Stress**
- Status line updates every frame
- Uses SGR + trailing spaces
- Overwrites only part of prior content

**Assertions**
- No attribute bleed
- Stable edge clipping
- Final framebuffer matches expected pattern

Each animation scenario must be executed at least twice without
reinitializing unrelated engine or renderer state.

Identical framebuffer output is required at defined checkpoints.

---

## D. Stress Content Suites

### Stress 1 ‚Äî Dense Scatter
Per frame:
- 50‚Äì200 small `drawRect`s
- Width: 1‚Äì8 glyphs
- Mixed `G0`, `G2`, `G5`

### Stress 2 ‚Äî Giant Write
Per frame:
- One `drawRect`
- Text payload larger than framebuffer capacity
- SGR sprinkled throughout

### Stress 3 ‚Äî Double Framebuffer Load
Two variants:
- **A:** single payload ‚âà `2 * C * R` characters
- **B:** same total payload spread across **2√ó frames**

These exercise different performance paths.

These two variants are intentionally non-equivalent:

- Variant A stresses parsing, clipping, and single-frame cost
- Variant B stresses scheduling, frame turnover, and state churn

Both must be retained to avoid masking performance regressions.


---

## E. Generator Structure (Conceptual)

Suggested generator boundaries:

- `genBoundaryTargets(cols, rows)`
- `genGlyphBundles()`
- `genPlacementCases(point, cols, rows)`
- `emitFramesForCase(case, glyphBundle)`

Suites built from these:
- `suite_boundary_matrix`
- `suite_playFrames_sequence`
- `suite_play_real_animation`
- `suite_stress_dense`
- `suite_stress_giant`
- `suite_stress_double`

---

## Scope Notes

- This document defines **content only**
- Harness mechanics, assertions, and perf measurement live elsewhere
- Any deviation from specified behavior must update this document

When in doubt: test content wins over intuition.
